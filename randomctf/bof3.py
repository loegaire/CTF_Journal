from math import gcd
from sympy import integer_nthroot

# Given values
n = 19276682022935745399516832355039300734984824856117920833153189519694368845964763910633866876108816499036115985302167273738881911234533339024836009753878249715998256605210678596704962764508163687536162707644215229783718454584819681411670316030802643996371073117371557685928142271465997502222477374211705271962178850563585790262083298859992969078953474573278244111329469188107665006948275686637221803784159528784103888321509305402691291667367262586326151575204588418022901545196311770507136253347466704109152903670962452105593189672114530364619357949712304267240841092630232642834629629131677071194036694449052736048021
e1 = 2897776246715
e2 = 30369827102730
c1 = 6423745578600023264377099763283342852656322662975983823689726727440168782203645248880450955097099239897639312184344765957088327212608040299639257606041148373335987854627811453625921562045526744907992810063983178648708535473690869707973021844205339896779315775040204847083633034806038007540012024394097613170260971559604036087435700243148506269857917484905470431122012731138666923251703305917720454507341395882693442693870060737600547803129842019157826356198676945173184361488115183685219303929155137725264121966976080825194937583574530220253077557728849380285275157887982064794973929537028871197550414793848393519937
c2 = 3771851869866021188042820686423051552526037073966477561021364499103088860353851909745403334698870936479543205869068252527271958963579438629950821247293398917553172609661874500834479177646170908274375067522344100271922972504536413377395840162160188389132380304102592591619902328086433666139961307482863104095658625235648073124241298774581061737702363302508575187766660654921214435239984493855576310638334856312881404136148112358490400964256034300482637190524620882615793726830299387990911399804954266539390806033476706086291446663392046405204179643366649047492919747068395266183312338118882460437686409629598676442526

# Step 1: Compute the GCD of e1 and e2
d = gcd(e1, e2)
print(f"GCD of e1 and e2: {d}")

if d == 1:
    raise ValueError("e1 and e2 are coprime. Use the standard Common Modulus Attack.")
else:
    print("e1 and e2 are not coprime. Adjusting the attack...")

# Step 2: Factor e1 and e2
e1_prime = e1 // d
e2_prime = e2 // d

# Step 3: Verify that e1' and e2' are coprime
if gcd(e1_prime, e2_prime) != 1:
    raise ValueError("e1' and e2' are not coprime. The attack cannot proceed.")
else:
    print("e1' and e2' are coprime. Proceeding with the attack...")

# Step 4: Use the Extended Euclidean Algorithm to find x and y for e1' and e2'
def extended_gcd(a, b):
    if b == 0:
        return (a, 1, 0)
    else:
        g, x, y = extended_gcd(b, a % b)
        return (g, y, x - (a // b) * y)

g, x, y = extended_gcd(e1_prime, e2_prime)

# Step 5: Compute m^d = (c1^x * c2^y) mod n
if x < 0:
    c1_inv = pow(c1, -1, n)
    term1 = pow(c1_inv, -x, n)
else:
    term1 = pow(c1, x, n)

if y < 0:
    c2_inv = pow(c2, -1, n)
    term2 = pow(c2_inv, -y, n)
else:
    term2 = pow(c2, y, n)

m_d = (term1 * term2) % n

# Step 6: Compute the d-th root of m_d to recover m
m, is_exact = integer_nthroot(m_d, d)
if not is_exact:
    raise ValueError("Could not compute the exact d-th root of m_d.")

# Step 7: Convert the plaintext to the flag
flag = m.to_bytes((m.bit_length() + 7) // 8, byteorder='big').decode('utf-8')
print(f"Flag: {flag}")
